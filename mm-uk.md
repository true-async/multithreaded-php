# Мультипотоковість у PHP: погляд у майбутнє

## Навіщо ця стаття?

У рамках [RFC TrueAsync 1.7](https://wiki.php.net/rfc/true_async) виникає питання: як запропонований RFC взаємодіятиме з можливими майбутніми змінами в ядрі PHP? Мати бодай уявлення, куди може рухатися PHP, — запорука грамотного дизайну мови на роки вперед. Саме тому з’явилася ця стаття.

Проєкт [TrueAsync](https://github.com/true-async/) — це не лише зміни ядра PHP заради асинхронності, а й інші дослідження, щоб відповісти на питання:

* Наскільки далеко PHP може зайти в бік мультипотоковості?
* Чи існують фундаментальні обмеження?
* Які зміни в ядрі можуть знадобитися, щоб мультипотоковість стала реальністю?
* Які мовні абстракції можна було б реалізувати?

Я не намагався зробити текст вичерпним оглядом усіх аспектів мультипотоковості в PHP чи технічно точним до дрібниць, зрозумілим для всіх. Проте сподіваюся, що стаття буде корисною широкому колу PHP‑розробників і задасть напрям для подальших дискусій.

## Історія

Кілька років тому, коли постало завдання додати великі обсяги телеметрії в PHP‑додаток, я сказав, що це неможливо. Але, познайомившись з архітектурою `Swoole`, стало цікаво перевірити це на практиці. Чи можна створити API, здатний генерувати й обробляти багато даних, не сповільнюючи клієнт?

Для цього створили оптимізовану версію `OpenTelemetry` для PHP, яка записувала дані частинами, збираючи великі чанки для відправки на проміжний сервер телеметрії. Використовувалося стиснення, а структури `JSON` серіалізувалися через `MessagePack`.

Головна гіпотеза: якщо використовувати однопотокові корутини, можна формувати телеметрію поступово й періодично передавати її на сервер за таймером або при перевищенні порога обсягу. Код буде швидким, бо немає міжпотокової взаємодії. Чи так це?

Експеримент показав: телеметрія знизила роботу API вдвічі. Гіпотеза провалилася. Чому? На _умоглядному_ рівні все виглядало логічно. `Swoole` вже робив функції PHP неблокуючими, тож корутини мали бути ефективними. Десь закралася помилка.

У другій версії телеметричні дані збиралися лише під час одного запиту і відразу скидалися в job‑процес, який займався агрегацією, стисненням і відправкою на сервер. Це рішення показало себе значно краще. Але ж так не повинно бути! Чи повинно? Дані між процесами надсилалися через `pipe`, серіалізувалися з одного боку й десеріалізувалися з іншого. Навіть якщо pipe у пам’яті, виклики ОС дорогі.

Згодом причину знайшли: телеметрії було багато, тож стиснення займало багато CPU порівняно з обробкою API‑запитів. Хоч корутини `Swoole` були ефективними для I/O, вони не допомогли в CPU‑інтенсивних задачах.

Цей випадок — один із багатьох, що показують: однопотокові корутини не вирішують усе. І демонструють, як мультипотоковість може доповнювати корутини, утворюючи набір інструментів для широкого спектра задач.

## Single-threaded + offload

Скидати CPU‑інтенсивну роботу в окремий процес — не «новий винахід». Це частина ширшої моделі, що незалежно з’явилася в різних мовах і фреймворках, і зветься **Single-threaded + offload**.

Уявіть: одна людина швидко сортує листи (тисячі на годину), а важкі посилки вантажать та везуть інші. Якщо сортувальник почне тягати посилки, черга листів виросте до стелі.

Модель `Single-threaded + offload` розділяє завдання на два типи:

1. **I/O-bound** — читання файлів, мережеві запити, доступ до БД. Більшість часу процес чекає на зовнішній світ. Тисячі таких операцій чудово поміщаються в один потік через конкурентну асинхронність (`корутини`, `await`).

2. **CPU-bound** — стиснення, шифрування, парсинг, обчислення. Тут CPU працює на повну, і простої конкурентності недостатньо — потрібні додаткові ядра.

Модель розділяє ці завдання **фізично**: головний потік (`Event Loop`) займається лише `I/O`, а `CPU`‑задачі відправляються в окремі потоки чи процеси (`Workers`).

**Node.js** славився однопотоковим `Event Loop`, що ідеально підходив для мережевих застосунків. Але коли в обробнику запиту намагалися обробляти зображення чи стискати відео, сервер перетворювався на гарбуз. Рішення — `Worker Threads`, окремі потоки для CPU‑важких операцій.

**Python** пішов схожим шляхом. З `asyncio` з’явився потужний інструмент для I/O‑коду, але GIL (Global Interpreter Lock) не дозволяв реального CPU‑паралелізму в одному процесі (на момент написання проблему вже вирішено). Для блокувальних операцій з’явилися `loop.run_in_executor()` і `asyncio.to_thread()` (з Python 3.9), які відправляють роботу в `thread pool` або `process pool`. Event loop лишається чутливим, обчислення йдуть паралельно.

**PHP/Swoole** побудований на тій самій архітектурі: `Request Workers` обробляють HTTP‑запити корутинами, а `Task Workers` виконують важкі обчислення. Через `UnixSocket` чи `pipe` можна обробляти ~100 тис. операцій на секунду на процес.

### Переваги моделі

**1. Ефективність ресурсів**

Однопотоковий event loop може обслуговувати тисячі паралельних I/O‑операцій із мінімальним overhead. Перемикання між задачами в корутинах дешевше, ніж контекст‑світч потоків ОС. `CPU-bound` задачі отримують справжній паралелізм на різних ядрах — кожен worker навантажує своє ядро, не заважаючи іншим.

**2. Простота розробки**

У коді event loop’а не потрібні м’ютекси, семафори та інші «принади» мультипотокового програмування. В однопотоковій моделі в кожен момент виконується рівно одна задача, тож **гонки** неможливі. `workers` працюють паралельно, але за принципу `Shared Nothing` проблем синхронізації немає.

Різниця в складності між мультипотоковим кодом і однопотоковою асинхронністю величезна. Не дивно, що сучасні мови й фреймворки тяжіють до однопотокової моделі з асинхронністю, а не до класичної мультипотоковості.

**3. Простота компілятора/рантайму**

Асинхронні функції в однопотоковій моделі значно простіші для компілятора і рантайму. Хороша мова з мультипотоковістю потребує власного процесу codegen. У PHP є серйозне обмеження: частина коду написана на C. Це позбавляє можливості робити ефективні оптимізації байткоду, керування пам’яттю, передачі параметрів з урахуванням мультипотоковості. Дизайн Go не випадково складний: власний стек, складний GC — усе це для ефективної роботи горутин і каналів. До GC PHP ми ще дійдемо.

**4. Ручний розподіл навантаження**

Розробник може свідомо розділити навантаження між кодом обробки запиту та кодом `worker pool`. Ручне керування дозволяє вичавити максимум із обладнання. Водночас це й недолік.

### Недоліки моделі

**1. Ручний розподіл навантаження**

Це обоюдогостра зброя. Можна оптимізувати під задачі, а можна помилитися й покласти важкі задачі в I/O‑код. Це може перевантажити I/O‑код, знизити чутливість сервера й збільшити латентність.

Модель вимагає достатньої кваліфікації від PHP‑розробників або покладання на продумані рішення фреймворків.

**2. Не для всіх задач**

`Single-threaded + offload` чудово підходить для веб‑серверів, API, мікросервісів, де основне навантаження — I/O з БД, файловими системами, мережею. Але для задач, що потребують інтенсивних обчислень на кожному кроці (наукові обчислення, рендеринг, ML), модель може бути менш ефективною; там краще підходить повноцінна мультипотоковість.

Можливо, ви скажете: з цим можна жити! Ми готові! Але чи готовий сам PHP стати мультипотоковим?

## Чи готовий PHP до мультипотоковості?

Під час розробки `TrueAsync` одна з найважчих дискусій була «чому в PHP немає асинхронності». Пояснити, чому PHP не готовий до мультипотоковості, може бути так само складно. Але спершу поговорімо про мультипотоковість. Навіщо вона потрібна — або краще: навіщо вона **НЕ ПОТРІБНА**.

> Мультипотоковість не потрібна для паралельного виконання коду.

Ідея, що мультипотоковість потрібна для паралельності, міцно засіла в свідомості програмістів, як ідея про те, що чорні діри «затягують» матерію, — у свідомості обивателів.

З паралельним виконанням чудово справляються процеси, ізольовані один від одного (починаючи з архітектури 80386). Процеси можуть взаємодіяти через `IPC`, а факт їх завершення відслідковується сигналами. Навіщо тоді потоки?

Щоб чесно відповісти, треба було б повернутися в минуле й запросити відомих людей, аби вони пояснили прийняті рішення: Едсгер Дейкстра, Фернандо Корбато, Барбара Лісков, Річард Рашид — вийшло б чудове ток‑шоу. Але навіть тоді чесну відповідь ми могли б не витягти.

Некоректно було б стверджувати:

> Потоки потрібні, щоб паралельний код міг ділити пам’ять без додаткових інструментів.

Процеси теж можуть ділити пам’ять, але треба відобразити сегмент у адресний простір (додатковий інструмент). Потоки ділять **усю** пам’ять процесу за замовчуванням. Буквально: якщо є змінна `x` у потоці `A`, то в потоці `B` вона доступна за тією ж адресою без хитрощів... Але ні! Кілька потоків **не можуть** працювати з однією змінною без інструментів.

Більш чесне формулювання:

> Потоки потрібні, щоб передавати пам’ять між задачами без додаткових витрат.

Якщо потоки використовують пам’ять для передачі повідомлень так, що лише один потік у момент часу має гарантований доступ до певної ділянки пам’яті, це максимально ефективно і за пам’яттю, і за процесором. При цьому потоки навмисно уникають спільних областей пам’яті. Ця модель зветься `Shared Nothing`.

Потоки потрібні, щоб ефективно передавати дані між задачами. Так само вірно, як і те, що «чорні діри не всмоктують».

## Модель пам’яті PHP

Як працює пам’ять у PHP? Спрощена абстрактна модель:
1. Код
2. Дані
3. Стан PHP VM

Можливість ділитися кодом PHP між потоками вже існує (вирішено з появою PHP JIT). Але інші компоненти тісно пов’язані. Наприклад, PHP використовує глобальне сховище всіх об’єктів `object_store`, що містить посилання на всі створені об’єкти. Менеджер пам’яті PHP створений для роботи з об’єктами однієї VM, не орієнтований на мультипотоковість. **Garbage Collector** PHP не може працювати з даними різних потоків і вимагає повної зупинки VM, бо прямо модифікує `refcount` об’єктів.

Отже, PHP — строго однопотокова модель із блокуючим GC.

### Переміщення PHP VM між потоками

PHP використовує **Thread-Local Storage (TLS)** для зберігання стану VM відносно потоку. Це критично важливий механізм, що забезпечує ізоляцію між потоками в режимі ZTS (Zend Thread Safety).

Щоб отримати вказівник на стан VM у сучасних збірках PHP, використовується оголошення «статичної» змінної за стандартом C11 `__thread` (або `__declspec(thread)` в MSVC). Швидкість такої операції максимально висока: на `x86_64` це зводиться до читання адреси за зміщенням від бази в регістрі `FS` або `GS`.

```asm
      ; offset - постійне зміщення, рахується під час компіляції
      ; fs - базова адреса сегмента
      mov rax, QWORD PTR fs:offset
```

Оскільки регістр `FS/GS` унікальний для кожного потоку (забезпечується ОС), читання з нього завжди повертає коректний вказівник на стан VM.

Можливість переміщати стан VM між потоками може бути корисною для реалізації фіч на кшталт Go‑подібних корутин або акторів. Сучасні VM забезпечують передачу контексту завдяки кастомному codegen, передаючи стан VM через регістри CPU. Для PHP такий трюк неможливий, бо під капотом С‑функції, а в C не існує способу передати контекст як прихований параметр усім функціям. Тож переміщення стану PHP VM між потоками коштуватиме певний відсоток від продуктивності.

А що, як переміщати не весь стан VM, а лише невелику його частину, потрібну для виконання коду? Наприклад, `PHP Fiber` копіює частину вказівників на глобальні структури (`zend_executor_globals`) при перемиканні.

Що як умовно розділити PHP VM на дві великі частини:
1. `PHP VM` shared. Класи, функції, константи, ini‑директиви, виконуваний код.
2. `PHP VM` movable. Частина VM, яку треба переміщати.

![PHP VM shared vs private](diagrams/tls-globals-structure.svg)

Частину структур можна позначити `shared`, частину `movable`, і навіть `Executor Globals` можна розділити на `shared` і `movable`, тим самим досягнувши ефективного переміщення стану VM між потоками. Глобальні структури розширень не втратять продуктивність через додатковий опосередкований доступ, бо вже його використовують.

Проблема виникає лише зі структурами, пов’язаними з компіляцією коду, адже PHP має динамічні особливості `include/require`, `eval`, автозавантаження. Саме вони заважають ефективно розділити стан VM на `shared` і `movable`. Але якщо придумати рішення, PHP зможе переносити частину стану VM між потоками з мінімальними накладними витратами.

## Передача об’єктів між потоками

Що треба змінити в PHP, щоб безболісно передавати об’єкти між потоками? Як це могло б працювати?

Спробуймо на рівні мови. Припустімо, є об’єкт `SomeObject` у `$obj`, і потрібно передати його в інший потік. Це можливо?

```php
$obj = new SomeObject();

$thread = new Thread(function () use ($obj) {
    echo $obj->someMethod();
});

$thread->join();
```

Оскільки `SomeObject` належить тільки `$obj`, ми могли б безпечно перенести його адресу з одного потоку в інший. При цьому змінна `$obj` в основному потоці була б знищена:

```php
$obj = new SomeObject();

$thread = new Thread(function () use ($obj) {
    echo $obj->someMethod();
});

// $obj is undefined here

$thread->join();
```

Код вище фактично 100% аналог операції переміщення, яка з’явилася в C++ і існує в Rust та інших мовах. Такий спосіб передачі пам’яті між потоками має переваги:
1. Безпека. Лише один потік володіє об’єктом.
2. Відсутність накладних витрат на копіювання чи серіалізацію.

Щоб код мав передбачувану поведінку й добре читався статичними аналізаторами, варто додати спеціальний синтаксис переміщення, наприклад так:

```php
$obj = new SomeObject();

// consume $obj вказує на переміщення об’єкта
$thread = new Thread(function () use (consume $obj) {
    echo $obj->someMethod();
});

// $obj is undefined here. Error should be reported here in PHP9.
echo $obj;
```

Виглядає чудово, чи не так?

Втім, у переміщення за `refcount = 1` є проблеми. Розгляньмо дерево категорій:

```php
$electronics = new CategoryNode('Electronics');

$categoriesTree = new Tree();
$categoriesTree->addToPath('/products/electronics', $electronics);
$categoriesTree->addToPath('/popular/electronics', $electronics);  // та сама категорія!
```

Об’єкт `$electronics` присутній у дереві двічі (`refcount = 2`). Що буде при спробі перемістити `$categoriesTree` в інший потік?

Для безпечного переміщення потрібно гарантувати, що всі об’єкти в графі не мають зовнішніх посилань:

```php
$node = new CategoryNode('Electronics');
$categoriesTree = new Tree();
$categoriesTree->addToPath('/products/electronics', $node);

$favourites = [$node];  // зовнішнє посилання!

$thread = new Thread(function () use ($categoriesTree) {
    // $categoriesTree переміщено
});

// $favourites[0] тепер вказує на пам’ять іншого потоку
// Dangling pointer!
```

Для гарантовано безпечного переміщення потрібно:

1. **Повний обхід графа** — перевірка всіх вкладених об’єктів.
2. **Перевірка refcount** — для кожного об’єкта.
3. **Збереження ідентичності** — дублікати всередині графа мають залишатися дублікатами.

Можна придумати кілька варіантів алгоритму, який можна назвати `deep copy`. Так могла б виглядати проста реалізація:

```php
// Псевдокод deep copy
// Вихідний граф у потоці A
$node = new Node('A');        // addr: 0x1000
$tree->left = $node;          // addr: 0x1000
$tree->right = $node;         // addr: 0x1000 (те саме посилання)

// Deep copy у потік B (псевдокод з MM)
$copied_map = [];  // hash table: addr_source -> addr_target

function deepCopyToThread(object $obj, Thread $target_thread_mm) 
{
    $source_addr = get_object_address($obj);

    if (isset($copied_map[$source_addr])) {
        return $copied_map[$source_addr];  // уже скопійовано!
    }

    // Алокуємо пам’ять у MM іншого потоку
    $new_addr = $target_thread_mm->allocate(sizeof($obj));
    $copied_map[$source_addr] = $new_addr;

    // Копіюємо дані об’єкта
    memcpy($new_addr, $source_addr, sizeof($obj));

    // Рекурсивно обходимо властивості
    foreach ($obj->properties as $prop) {
        if (is_object($prop)) {
            $new_prop_addr = deepCopyToThread($prop, $target_thread_mm);
            // Оновлюємо вказівник у новому об’єкті
            update_property($new_addr, $prop, $new_prop_addr);
        }
    }

    return $new_addr;
}

// Результат у потоці B:
// $newTree->left (addr: 0x2500) === $newTree->right (addr: 0x2500)
// Ідентичність збережено!
```

**Складність deep copy**: `O(N + E)`, де `N` — кількість об’єктів, `E` — кількість посилань.
**Просторова складність**: `O(N)` — хеш‑таблиця + нові об’єкти + стек рекурсії.

Порівняно з серіалізацією це може бути швидшим, бо не потребує перетворення в транспортний формат і назад, але виграш залежить від характеру даних і розміру графа. Можна зробити гібрид: переміщувати дані з `refcount = 1`, а для інших запускати `deep copy`.

Отримуємо результат:
1. Розробнику PHP не потрібно думати, як об’єкти передаються в інший потік.
2. У кращому випадку пам’ять буде переміщено (`refcount = 1`).
3. У гіршому — пам’ять буде скопійовано алгоритмом `deep copy` зі збереженням ідентичності структури (`refcount > 1`).

Виглядає добре:
* мінімальні зміни синтаксису PHP
* зміни можуть бути поступовими
* мультипотоковість стає доступною

Але на рівні ядра не все так чудово. Щоб переміщення об’єкта стало реальністю, PHP потрібен механізм керування пам’яттю в різних потоках. Наразі це неможливо.

## Мультипотокова версія PHP Memory Manager

Менеджер пам’яті PHP багато в чому схожий на сучасні алокатори, такі як `jemalloc` чи `tcmalloc`. Відмінність — у ньому немає алгоритму коректного звільнення пам’яті з іншого потоку.

Розглянемо ситуацію:
* Об’єкт створено в потоці `A`.
* Передано в потік `B` через переміщення (як є).
* У потоці `B` об’єкт більше не потрібен і має бути звільнений.

У кожному потоці PHP є свій `Memory Manager (MM)`. Коли потік `B` намагається звільнити пам’ять, виділену в `A`, виникає проблема. MM потоку `B` нічого не знає про пам’ять `A`, і спроба звільнити її призводить до помилки. Прямий доступ до структур MM `A` з `B` — погана ідея, бо вимагає синхронізації. Сучасні високопродуктивні мультипотокові менеджери вирішують це через відкладене звільнення (`deferred free`).

Загальна ідея `deferred free`:
1. MM потоку `B` бачить, що адреса об’єкта йому невідома.
2. Він знаходить, якому MM належить вказівник, і надсилає повідомлення в чергу про те, що вказівник можна звільнити.
3. MM потоку `A` обробляє чергу і звільняє вказані вказівники у своєму контексті.

![Cross-thread deallocation](diagrams/cross-thread-free.svg)

Такий алгоритм на сучасних lock-free структурах має високу пропускну здатність, дозволяє різним потокам паралельно звільняти пам’ять і майже не потребує блокувань.

Мультипотокова версія менеджера пам’яті PHP відкриває двері для інших змін, які раніше були неможливі.

## Shared objects

Мати можливість передавати пам’ять з одного потоку в інший із мінімумом операцій — добре, але що, якби ми могли створювати об’єкти, які з самого початку призначені для спільного використання між потоками?

Багато сервісів можна побудувати як іммутабельні об’єкти, отже їх слід чесно ділити між процесами, що дозволить ще краще економити пам’ять і швидше ініціалізувати PHP‑воркери.

На жаль, для реалізації таких об’єктів заважає `refcount`, бо він фактично робить усі об’єкти PHP мутабельними. Чи можна це обійти?

### Proxy objects

Перший підхід — створення проксі‑об’єктів, які посилаються на реальні об’єкти в спільному пулі пам’яті, доступному для всіх потоків. Проксі містять лише ідентифікатор чи вказівник на реальний об’єкт і методи доступу. Недоліки:
* збільшує час доступу до даних, властивостей
* ускладнює роботу з `Reflection API` і визначення типу

З іншого боку, PHP уже має розвинений механізм проксі. У деяких випадках Proxy‑shared об’єкти чудово підходять, наприклад, для таблиці лічильників або таблиці даних на кшталт Swoole/Table.

### Shared objects із прапором GC_SHARE

У PHP є механізм для **immutable** елементів через прапор `GC_IMMUTABLE`. Його використовують для:

- **Інтерновані рядки** (`IS_STR_INTERNED`) — рядкові константи, що живуть увесь час роботи PHP
- **Immutable масиви** (`IS_ARRAY_IMMUTABLE`) — наприклад, `zend_empty_array`
- **Константи в opcache** — скомпільований код із константними даними

Прапор `GC_IMMUTABLE` дозволяє рушію PHP **пропускати** операції зміни `refcount` для таких структур:

```c
// Zend/zend_types.h
// Код функції, що збільшує refcount для zend_refcounted_h
static zend_always_inline void zend_gc_try_addref(zend_refcounted_h *p) {
    if (!(p->u.type_info & GC_IMMUTABLE)) {
        ZEND_RC_MOD_CHECK(p);
        ++p->refcount;
    }
}
```

Схожий механізм можна використати для `SharedObjects`. Наприклад, визначити прапор `GC_SHARE`.

Аналіз продуктивності показує, що перевірка `GC_SHARE` додає **+34% overhead** до ізольованої операції `refcount++` (мікробенчмарк). У реальних застосунках, де операції з `refcount` — мала частка загальної роботи, вплив має бути майже непомітним:

- **Реалістичні операції** (робота з масивами/об’єктами): +3-9%
- **Реальні застосунки**: +0.05-0.5%

Такий підхід вирішує половину проблеми, друга половина — розробка механізму збору сміття для такого об’єкта. Використовувати atomic refcount — не найкраща ідея через можливе зниження продуктивності при активному доступі різних потоків до одного об’єкта. Найімовірніше тут підійде алгоритм `deferred free`.

### Region-based memory

Зараз `region-based memory` — популярний підхід до керування пам’яттю в мовах, орієнтованих на Web.

Ідея в тому, щоб виділяти пам’ять для певних задач або потоків в окремих регіонах, які можна звільняти цілком (або майже), коли вони більше не потрібні. Це дозволяє уникнути складностей керування пам’яттю на рівні окремих об’єктів і спрощує роботу GC.

Так, наприклад, `PHP MM` може гарантувати створення об’єктів у певному регіоні пам’яті, який буде пов’язаний із конкретним PHP‑об’єктом. Час життя регіону дорівнює часу життя об’єкта.

Коли об’єкт знищується, весь регіон пам’яті можна звільнити цілком, без обходу дочірніх елементів. А якщо такий об’єкт потрібно «перемістити» з потоку в потік, можна уникнути операції `deep copy`.

PHP VM має проблеми з реалізацією `region-based memory`, наприклад глобальний список об’єктів, кешування в опкодах. Але шанси на ефективну реалізацію не дорівнюють нулю й потребують подальших досліджень.

Робочий алгоритм `region-based memory` відкриває можливості для імплементації акторів — спеціальних об’єктів з ізольованою пам’яттю.

Актори — найзручніший, найпотужніший і найбезпечніший інструмент для мультипотокового програмування.

## Взаємодія корутин і Threads

З точки зору корутини, `Thread` — це об’єкт `Awaitable`. Отже, корутина може чекати результат виконання `Thread`, не блокуючи інші корутини. Тобто в одному потоці можуть існувати багато корутин, що чекають на виконання важких задач. При цьому потік, що їх обслуговує, зберігає здатність швидко реагувати на нові запити, адже очікування `Thread` не блокує `Event Loop`.

```php
use Async\await;
use Async\Thread;

$thread = new Thread(function() {
    // hardware-bound task here
    return 42;
});

$result = await($thread); // Корутина зупиняється тут, до завершення Thread
```

Подібний підхід дозволяє реалізувати сценарій роботи чату, де є `CPU`‑інтенсивні задачі й проста бізнес‑логіка.

![Thread + Coroutine architecture](diagrams/chat-sequence.svg)

На діаграмі — приклад архітектури. Застосунок складається з двох пулів потоків: потоки обробки запитів із конкурентною багатозадачністю та worker‑потоки для `CPU`‑інтенсивних задач. Корутина обробляє один запит, може повністю зупинитися, очікуючи, коли worker виконає важку задачу, і потім продовжити.

```php
use Async\await;
use Async\ThreadPool;

final readonly class ImageDto
{
    public function __construct(
    public int $width,
    public int $height,
    public string $text,
) {}
}

$pool = new ThreadPool(2);
$dto = new ImageDto(
    width: 200,
    height: 200,
    text: 'Hello TrueAsync!'
);

$image = $pool->enqueue(function (ImageDto $dto) {
    $img = imagecreatetruecolor($dto->width, $dto->height);

    $white = imagecolorallocate($img, 255, 255, 255);
    $black = imagecolorallocate($img, 0, 0, 0);

    imagefill($img, 0, 0, $white);
    imagestring($img, 5, 20, 90, $dto->text, $black);

    ob_start();
    imagepng($img);
    imagedestroy($img);
    return ob_get_clean();
}, $dto);

$response->setHeader('Content-Type', 'image/png');
$response->write($image);
$response->end();
```

Код корутини виглядає послідовним і сприймається так, ніби `ThreadPool::enqueue` викликає callback у тому ж потоці. Об’єкт DTO переходить від одного потоку до іншого, а результуючий рядок не копіюється в пам’яті двічі.

## Garbage Collector і stateful режим

Модернізація менеджера пам’яті PHP — не єдина зміна, потрібна для покращення роботи мови у мультипотоковому середовищі. Без ефективного збирача сміття мультипотоковий PHP страждатиме від проблем з продуктивністю й витоків пам’яті через цикли.

Garbage Collector PHP використовує комбінацію двох алгоритмів: **reference counting** (підрахунок посилань) як основний механізм керування пам’яттю та **Concurrent Cycle Collection** (алгоритм Bacon-Rajan, 2001) для виявлення циклів. Reference counting інкрементує та декрементує лічильник при кожному присвоєнні, що робить неможливим його безпечне використання в мультипотоковому середовищі без синхронізації. Атомарні операції для кожного присвоєння створили б величезний overhead, а відсутність синхронізації призвела б до гонок і витоків пам’яті. Cycle collector, хоча й називається «concurrent», працює лише в контексті одного потоку і використовує кольорове маркування (**PURPLE** → **GREY** → **WHITE/BLACK**) для виявлення циклів, яке також не є thread-safe.

Позитивний момент: поточна реалізація GC PHP буде працювати в мультипотоковому середовищі, бо вона відокремлена від менеджера пам’яті й не залежить від того, де пам’ять була виділена.

Але якщо PHP хоче увійти в еру мультипотокових stateful застосунків, збирач сміття треба адаптувати, щоб вирішити такі задачі:
1. Уміти працювати **паралельно** в окремому потоці, не впливаючи на бізнес‑код.
2. Ефективно звільняти ресурси так швидко, як це можливо.
3. Надавати додаткові інструменти для виявлення, логування витоків пам’яті, телеметрії (особливо актуально для тривалих застосунків!).

Алгоритм `Cycle Collection` можна змінити для роботи в мультипотоковому середовищі, обробляючи посилання в окремому потоці, що підвищить загальну чутливість PHP‑застосунку. Для початку цього може бути достатньо.

## Актори

Звісно, `ThreadPool` і можливість передавати об’єкти між потоками корисні, але вимагають уваги, кваліфікації й зусиль. Є краща абстракція для мультипотокового програмування, яка приховує складнощі роботи з потоками й пам’яттю і ідеально підходить для бізнес‑логіки. Вона зветься — **Актори**.

Актори — це модель конкурентного паралельного програмування, де базовою одиницею обчислень є **актор**.

Кожен актор:
- Має власний ізольований стан
- Обробляє повідомлення послідовно
- Взаємодіє з іншими акторами лише через повідомлення
- Може виконуватися в окремому потоці

Про актора можна думати як про об’єкт, що робить можливим використання звичних для PHP парадигм ООП у мультипотоковому програмуванні.

Уявімо чат‑сервер із багатьма кімнатами. Кожна кімната — окремий об’єкт.

```php
use Async\Actor;

class ChatRoom extends Actor
{
    private array $messages = [];
    private string $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function postMessage(string $user, string $text): void
    {
        $this->messages[] = [
            'user' => $user,
            'text' => $text,
            'time' => time()
        ];
    }

    public function getMessages(): array
    {
        return $this->messages;
    }
}

spawn(function() {
   $room = new ChatRoom('general');
   $room->postMessage('Alice', 'Hello!');  // Виконується в іншому потоці, блокує корутину!
   $messages = $room->getMessages();       // Виконується в іншому потоці, блокує корутину!
   echo json_encode($messages);
});
```

Об’єкти класу `ChatRoom` особливі. Їхні дані, стан PHP VM локалізовані так, щоб легко переміщатися між потоками. Кожен метод виконується окремо у своєму потоці, але в один момент лише один потік може виконувати методи одного актора.

З точки зору семантики мови, базовий клас `Actor` визначає роботу `PHP VM` і менеджера пам’яті так, щоб об’єкти класу `ChatRoom` могли безпечно виконуватися в окремих потоках. Тобто тип класу «зберігає» не лише інформацію про методи й властивості, а й про те, як має працювати менеджер пам’яті та збирач сміття для таких об’єктів. Схожий підхід можна побачити в інших мовах: `Rust`, `C++`. Плюс: не потребує змін у синтаксисі й органічно вписується в існуючу філософію ООП.

Приклад нагадує звичайний послідовний код у середині корутини. Але оскільки методи `postMessage` і `getMessages` виконуються в іншому потоці, насправді їх прямого виконання не відбувається. Корутина посилає **повідомлення** в чергу актора, переходить у стан очікування й відновлюється лише тоді, коли актор виконає метод в іншому потоці й поверне результат.

Нічого з цього не суперечить звичній моделі ООП у PHP, оскільки в класі `Actor` перевизначено магічний метод `__call`:

```php
class Actor 
{
    private $threadPool;

    public function __call(string $name, array $arguments): mixed
    {
        if(current_thread_id() === $this->threadPool->getThreadIdForActor($this)) {
            // Виконуємо метод напряму, якщо ми в тому ж потоці
            return $this->$name(...$arguments);
        }
    
        // Інакше ставимо виклик у чергу актора
        return $this->threadPool->enqueueActorMethod($this, $name, $arguments);
    }
}
```

Метод `enqueueActorMethod` додає в чергу актора виклик `postMessage`, підписується на подію результату й викликає функцію `Async\suspend()` для зупинки корутини. 

Код актора виконується послідовно, що вирішує проблеми гонок даних і робить мультипотокову розробку прозорою для програміста.

Розпаралелювання досягається за рахунок того, що кожен актор `ChatRoom` отримує шанс виконуватися в окремому потоці:

```php
spawn(function() {
   $room = new ChatRoom('room1');
   $room->postMessage('Alice', 'Hello!');
   $messages = $room->getMessages();
   echo json_encode($messages);
});

spawn(function() {
   $room = new ChatRoom('room2');
   $room->postMessage('Bob', 'Hi there!');
   $messages = $room->getMessages();
   echo json_encode($messages);
});
```

Код різних об’єктів `ChatRoom` може виконуватися паралельно в різних потоках, адже кожен актор має свій потік виконання, унікальний стан PHP VM і пам’ять.

Створимо **100 чат‑кімнат**:

```php
use Async\Actor;

$rooms = [
    'general' => new ChatRoom('general'),
    'random'  => new ChatRoom('random'),
    'tech'    => new ChatRoom('tech'),
    // ... ще 97 кімнат
];

// Корутина для обробки запитів
HttpServer::onRequest(function(Request $request, Response $response) use ($rooms) {
   // Обробка HTTP‑запиту
   $roomName = $request->getQueryParam('room');
   $room = $rooms[$roomName] ?? null;
   
   if (!$room) {
      $response->setStatus(404);
      $response->write('Room not found');
      $response->end();
      return;
   }
   
   // Виклики виглядають синхронними, але виконуються в іншому потоці!
   $room->postMessage($request->getQueryParam('user'), $request->getQueryParam('text'));
   $messages = $room->getMessages();
   
   $response->setHeader('Content-Type',  'application/json');  
   $response->write(json_encode($messages));
   $response->end();
});
```

Кожна чат‑кімната обробляє повідомлення послідовно й паралельно щодо інших кімнат. 

Актори не потребують м’ютексів, блокувань, складної синхронізації чи ручної взаємодії з пулом потоків. Вони надають готове високорівневе рішення для розпаралелювання задач.

Якщо одній чат‑кімнаті потрібно послати повідомлення в іншу, це можливо, адже актори — `SharedObject`, можуть взаємодіяти в різних потоках:

```php
class Rooms extends Actor
{
    private array $rooms = [];
    
    public function __construct(string ...$roomNames)
    {
       foreach ($roomNames as $name) {
           $this->rooms[$name] = new ChatRoom($name);
       }
    }
    
    public function broadcastMessage(string $fromRoom, string $user, string $text): void
    {
        foreach ($this->rooms as $name => $room) {
            if ($name !== $fromRoom) {
                // Неблокувальний виклик
                $room->postMessageAsync($user, $text);
            }
        }
    }
}

spawn(function() {
   $rooms = new Rooms('general', 'room1', 'room2', 'room3');
   $rooms->broadcastMessage('general', 'Alice', 'Hello!');
});

```        
    
### Внутрішня архітектура акторів

PHP VM гарантує, що всі об’єкти всередині актора:
* або належать тільки цьому актору й виділені в його унікальному region,
* або належать і переміщені з інших регіонів чи потоків,
* або є іншим SharedObject чи іншим актором.

Актор або володіє своїм region, або працює лише з явно розділеними immutable об’єктами — інакше залишаються гонки.

Менеджер пам’яті забезпечує й гарантує, що всі операції з пам’яттю всередині методів актора автоматично пов’язані з ним через регіон пам’яті, прямо асоційований з актором.

Для виконання методів використовується `MPMC` черга повідомлень, яку обслуговує `Scheduler`. Саме `Scheduler` розподіляє час процесора між акторами, забезпечуючи конкурентне й паралельне виконання.

![Actor model architecture](diagrams/actor-message-flow.svg)

## Висновок

Усе це, звісно, добре, але коли ж ми побачимо це в реальності? — спитаєте ви.

Модель `Single-threaded + offload` має всі шанси з’явитися найближчим часом, адже багато компонентів уже готові. `TrueAsync`: однопотокові корутини дійшли до стану бети. Реалізована експериментальна версія мультипотокового менеджера пам’яті та `API` для створення потоків. 

Актори потребують більше часу на розробку, адже зачіпають багато частин ядра PHP, і є реалістичною гідною ціллю для `PHP 9`, пропонуючи ринку безпечну мультипотокову мову програмування.
