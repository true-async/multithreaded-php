# Многопоточность в PHP: взгляд в будущее

## Зачем эта статья?

В рамках [RFC TrueAsync 1.7](https://wiki.php.net/rfc/true_async) возникает вопрос: 
как предлагаемый `RFC` будет взаимодействовать с возможными будущими изменениями в ядре PHP.
Возможность иметь хотя бы представление о том, как `PHP` может развиваться в будущем,
является залогом хорошего дизайна языка на много лет вперёд. Вот почему появилась эта статья.

Проект [TrueAsync](https://github.com/true-async/) это не только изменения ядра `PHP` ради асинхронности, но и другие 
исследования, которые необходимы, для ответа на вопросы:

* Насколько далеко может зайти PHP в сторону многопоточности? 
* Существуют ли фундаментальные ограничения?
* Какие изменения в ядре PHP могут понадобиться, чтобы сделать многопоточность реальностью?
* Какие языковые абстракции могут быть реализованы?

Я не пытался сделать текст исчерпывающим обзором всех аспектов многопоточности в PHP, и не пытался 
сделать его технически точным во всех деталях, или понятным широкой аудитории. Однако, я надеюсь, что статья
будет полезна широкому кругу PHP-программистов, и задаст вектор для дальнейших дискуссий.

## История

Когда несколько лет назад возникла задача добавить телеметрию большого объёма в приложение на `PHP`,
я сказал, что это невозможно.
Но столкнувшись с архитектурой `Swoole`, стало интересно проверить утверждение на практике. А можно ли создать `API`, 
который бы был способен генерировать и обрабатывать большой объём данных таким образом, чтобы не замедлять 
взаимодействие с клиентом.

Для этого была создана оптимизированная версия `OpenTelemetry` для `PHP`, которая записывала данные
по частям, формируя более большой чанк для отправки на промежуточный сервер телеметрии. При передаче данных 
использовалось сжатие, а `JSON` структуры сериализировались с помощью `MessagePack`.

Основная гипотеза выглядела так: если использовать однопоточные корутины можно формировать телеметрию постепенно, 
а потом периодически передавать её на сервер по таймеру или по достижении границы объёма данных. 
Код будет быстрым, потому что в нём не будет межпотокового 
взаимодействия. Так ли это?

Эксперимент показал, что телеметрия просадила работу `API` в два раза. Гипотеза провалилась. Но почему? 
Ведь на уровне _умозрительного_ представления всё выглядело логично. `Swoole` на тот момент уже умел делать функции `PHP`
не блокирующими, а значит корутины должны были работать эффективно. Но где-то закралась ошибка.

Во второй версии телеметрические данные собирались только во время одного запроса, 
и сразу сбрасывались в Job-процесс, который занимался агрегацией, 
сжатием и отправкой телеметрии на сервер. Это решение показало себя гораздо лучше. 
Но так ведь быть не должно?! Или должно?
Данные между процессами посылались через `pipe`, они сериализировались на одной стороне и десериализовались на другой.
Даже если `pipe` на самом деле находится в памяти, вызовы `OS` стоят дорого.

Позже причина была найдена: данных телеметрии было много, поэтому сжатие занимало много процессорного времени
относительно обработки API-запросов. Таким образом, несмотря на то, что корутины `Swoole` были эффективны для
ввода-вывода, они не помогали в решении CPU-интенсивных задач.

Этот случай один из многих, которые показывают, что однопоточные корутины не решают всех проблем. А также
он демонстрирует, как многопоточность может дополнять корутины, 
образуя ансамбль инструментов для решения широкого спектра задач.

## Single-threaded + offload

Решение сбрасывать CPU-интенсивную работу в отдельный процесс не было "новым изобретением". 
Оно является частью более общей модели, которая независимо появилась
в разных языках и фреймворках и получила название **Single-threaded + offload**.

Представьте: один человек быстро сортирует письма (тысячи в час), 
а тяжёлые посылки грузят и везут другие сотрудники на грузовиках.
Что произойдёт, если сортировщик начнёт таскать посылки? Очередь из писем вырастет до потолка.

Модель `Single-threaded + offload` разделяет задачи на два типа:

1. **I/O-bound задачи** — чтение файлов, сетевые запросы, обращения к БД. Львиную долю времени
   процесс ждёт ответа от внешнего мира. Тысячи таких операций прекрасно упаковываются
   в один поток через конкурентную асинхронность (`корутины`, `await`).

2. **CPU-bound задачи** — сжатие данных, шифрование, парсинг, вычисления. Здесь процессор работает
   на полную мощность, и конкурентность не поможет — нужны реальные вычислительные мощности,
   то есть дополнительные ядра CPU.

Модель разделяет эти задачи **физически**: главный поток (`Event Loop`) занимается только `I/O`,
а `CPU-задачи` отправляются в отдельные потоки или процессы (`Workers`).

**Node.js** изначально славился своим однопоточным `Event Loop`'ом, который идеально подходил для
сетевых приложений. Но когда разработчики пытались обрабатывать изображения или сжимать видео
прямо в обработчике запроса, сервер превращался в тыкву. Решение пришло в виде `Worker Threads` —
отдельных потоков для CPU-интенсивных операций.

**Python** пошёл похожим путём. Вместе с `asyncio` язык получил мощный инструмент для I/O-bound кода,
но встроенный GIL (Global Interpreter Lock) не даёт реально распараллелить CPU-вычисления в рамках
одного процесса (эту проблему уже решили на момент написания статьи). 
Поэтому для блокирующих операций появились `loop.run_in_executor()` и
`asyncio.to_thread()` (с Python 3.9), которые отправляют тяжёлую работу в отдельный `thread pool`
или `process pool`. `Event loop` остаётся отзывчивым, а вычисления идут параллельно.

**PHP/Swoole** построен на той же архитектуре:
`Request Workers` обрабатывают HTTP-запросы с помощью корутин, а `Task Workers` занимаются тяжёлыми
вычислениями. Взаимодействие через `UnixSocket` или `pipe` позволяет обрабатывать ~100 тысяч операций в секунду
на один процесс.

### Преимущества модели

**1. Эффективность использования ресурсов**

`Event Loop` на одном потоке может обслуживать тысячи одновременных I/O операций с минимальным overhead.
Переключение между задачами в корутинах стоит дешевле по сравнению с переключением контекста между
потоками на уровне ОС. `CPU-bound` задачи получают настоящий параллелизм на разных ядрах процессора —
каждый worker грузит своё ядро, не мешая соседям.

**2. Простота разработки**

В коде `Event Loop`'а не нужны мьютексы, семафоры и прочие "радости" многопоточного программирования.
Однопоточная модель означает, что в один момент времени выполняется ровно одна задача, поэтому
**race conditions** невозможны. `workers` работают параллельно, но если следовать принципу
`Shared Nothing`, то проблемы синхронизации не возникают.

Стоит отметить, что разница между сложностью программирования в многопоточной среде по сравнению 
с однопоточной конкурентной средой огромна. Неслучайно современные языки и фреймворки
стремятся к однопоточной модели с асинхронностью, а не к классической многопоточности.

**3. Простота компилятора/языка**

Асинхронные функции в однопоточной модели проще для компилятора и рантайма. Намного проще!
Хороший язык с многопоточностью требует своего процесса кодогенерации. 
В этом аспекте у `PHP` существует серьёзное ограничение: часть кода написана на `С`. Это лишает возможности создавать 
эффективные оптимизации на уровне байткода, управление памятью, передачу параметров, которые бы учитывали многопоточность.
Дизайн языка `Go` не случайно является одним из самых сложных: проприетарный стек, сложный сборщик мусора,
всё это необходимо для эффективной работы с горутинами и каналами.
Впрочем, дальше мы ещё доберёмся до сборщика мусора PHP, так что не время расслабляться!

**4. Ручное распределение нагрузки**

У программиста появляется шанс осознанно разделить нагрузку между кодом логики обработки запроса 
и кодом `worker pool`. Ручное управление даёт возможность 
выжать теоретический максимум из оборудования. Но с другой стороны это так же является недостатком.

### Недостатки модели

**1. Ручное распределение нагрузки**

Ручное распределение нагрузки — обоюдоострое копьё. С одной стороны, программист может оптимизировать
код под конкретные задачи, с другой — ошибиться, неправильно оценить, что должно идти в `IO-bound` код,
а что в `workers`. В результате `IO-bound` код может быть перегружен тяжёлыми задачами, 
что приведёт к деградации отзывчивости сервера, увеличению латентности.

Модель требует от программистов `PHP` быть достаточно квалифицированными, 
или же полагаться на других квалифицированных программистов (использовать продуманные решения от фреймворков).

**2. Не для всех задач**

Модель `Single-threaded + offload` отлично подходит для веб-серверов, `API`, микросервисов,
где основная нагрузка — это `I/O` операции с базами данных, файловыми системами, сетевыми запросами.
Однако для задач, которые требуют интенсивных вычислений на каждом шаге, 
например, научные вычисления, рендеринг графики, машинное обучение, 
модель может быть менее эффективной. В таких случаях лучше подходят модели с полноценной
многопоточностью, где каждая задача может использовать все доступные ресурсы.

Возможно, вы скажете: с этим можно жить! Мы готовы! Но готов ли сам PHP стать многопоточным? 

## Готов ли PHP к многопоточности?

Во время разработки `TrueAsync` одним из самых сложных вызовов стала дискуссия: 
"почему в PHP нет асинхронности". Возможно, попытка объяснить, почему `PHP` не готов к многопоточности,
столкнётся с такими же трудностями. Но для начала, давайте поговорим про многопоточность. Зачем она нужна? 
Или лучше: зачем она **НЕ НУЖНА**. 

> Многопоточность не нужна для параллельного выполнения кода.

Идея, что многопоточность необходима для параллельного выполнения, 
попала глубоко в сознание программистов с начала времён,
точно так же, как идея о том, что чёрные дыры "засасывают" материю, попала в умы обывателей.

С параллельным выполнением отлично справляются процессы, которые при этом изолированы друг от друга 
(начиная с 80386 архитектуры). Процессы могут взаимодействовать друг с другом с помощью `IPC`,
а факт их завершения отслеживается с помощью сигналов (событий ОС). Зачем тогда нужны потоки?

Чтобы дать честный ответ на этот вопрос, придётся отправиться в далёкое прошлое и призвать 
известных людей, чтобы они лично смогли ответить на вопросы или хотя бы попытаться объяснить принятые решения. 
Эдсгер Дейкстра, Фернандо Корбато, Барбара Лисков, Ричард Рашид, уверен, у нас бы получилось отличное
ток-шоу с их участием. Но боюсь, что, даже если бы они вызвались на интервью, 
честный ответ мы бы всё равно не смогли извлечь.

Некорректно было бы утверждать, что: 

> Потоки нужны, чтобы параллельный код мог разделять память без дополнительных инструментов.

Процессы тоже могут разделять память, 
но для этого нужно отразить участок памяти в адресное пространство (дополнительный инструмент).
Потоки разделяют **всю память** процесса по-умолчанию. Буквально, если есть переменная `x` и она доступна в потоке `A`, 
то и в потоке `B` она доступна по тому же адресу без каких-либо ухищрений...
Но нет! Несколько потоков **не могут** работать с одной переменной без дополнительных инструментов. 

Поэтому более честное утверждение могло бы звучать так:

> Потоки нужны, чтобы передавать память между задачами без дополнительных затрат

Если потоки используют память для передачи сообщений так, 
чтобы только один поток в один момент времени гарантированно имел доступ к определённому участку памяти,
то это максимально эффективная модель и с точки зрения памяти, и с точки зрения процессора.
При этом потоки намеренно избегают участков памяти, которые были бы общими. 
Данная модель получила название `Shared Nothing`.  

Потоки нужны, чтобы эффективно передавать данные между задачами. 
Так же верно, как и то, что "чёрные дыры не сосут".

## Модель памяти PHP

А как работает память в `PHP`?
Абстрактную модель памяти `PHP`, упрощённо можно описать следующим образом:
1. Код
2. Данные 
3. Состояние PHP VM

Возможность разделить код `PHP` между потоками уже существует (задача была решена с появлением `PHP JIT`).
Но остальные компоненты тесно связаны друг с другом. Их нельзя просто так разорвать. Например, `PHP` использует
глобальное хранилище всех объектов `object_store`, которое содержит ссылки на все созданные объекты.
Менеджер памяти `PHP` создан таким образом, чтобы работать с объектами из одного `PHP VM`,
и никак не ориентирован на многопоточность. **Garbage Collector** (GC) `PHP` не может работать с данными разных потоков, 
более того, требует полной остановки `PHP VM`, так как напрямую модифицирует `refcount` объектов.

Таким образом `PHP` — строго однопоточная модель, с блокирующим `GC`.

### Перемещение PHP VM между потоками

`PHP` использует **Thread-Local Storage (TLS)** для хранения состояния виртуальной машины относительно потока. 
Это критически важный механизм, который обеспечивает изоляцию между потоками в ZTS-режиме (Zend Thread Safety).

Чтобы получить указатель на состояние `VM` в современных сборках `PHP`, используется 
объявление "статической" переменной по стандарту C11 `__thread` (или `__declspec(thread)` в MSVC). 
Скорость такой операции максимально высока, и на `x86_64` архитектуре сводится 
к чтению адреса по смещению с базой в регистре `FS` или `GS`.

```asm
      ; offset - постоянное смещение, рассчитывается в момент компиляции
      ; fs - базовый адрес сегмента памяти
      mov rax, QWORD PTR fs:offset
```

Так как регистр `FS/GS` уникален для каждого потока (обеспечивается операционной системой), 
чтение из него всегда возвращает корректный указатель на состояние `VM`. 

Возможность перемещать состояние VM между потоками может быть полезной для реализации таких фич, как Go-like корутины 
или акторы. Современные VM обеспечивают передачу контекста 
благодаря кастомной кодогенерации, передавая состояние VM через регистры `CPU`.
Для `PHP` такой трюк невозможен, так как под капотом он использует `С`-функции, 
а в `С` не существует способа указать контекст как особый параметр, который бы передавался всем функциям скрытно. 
Поэтому перемещение состояния PHP VM между потоками будет стоить некий процент от общей производительности.

Но что, если можно перемещать не всё состояние VM, а лишь небольшую его часть, необходимую для выполнения кода?
Например, `PHP Fiber` копирует часть указателей на глобальные структуры (`zend_executor_globals`) при переключении.

Что если `PHP VM` можно условно разделить на две большие части:
1. `PHP VM` shared. Классы, функции, константы, ini директивы, исполняемый код.
2. `PHP VM` movable. Часть виртуальной машины, которую нужно перемещать.

![PHP VM shared vs private](diagrams/tls-globals-structure.svg)

Часть из этих структур может быть помечена как `shared`, а часть как `movable`, и даже 
`Executor Globals` можно разделить на `shared` и `movable` части и тем самым добиться эффективного 
перемещения состояния VM между потоками. Глобальные структуры расширений не потеряют производительность
из-за дополнительного косвенного доступа, так как уже его используют.

Проблема возникает только со структурами, относящимися к компиляции кода, 
так как у `PHP` есть динамическая природа в виде `include/require`, `eval`, автозагрузки классов.
Именно эти особенности мешают эффективно разделить состояние VM на `shared` и `movable` части.
Но если придумать решение для этой проблемы, `PHP` сможет переносить 
часть состояния VM между потоками с минимальными накладными расходами.

## Передача объектов между потоками

Что нужно изменить в `PHP`, чтобы позволить безболезненно передавать объекты между потоками?
Как такая функциональность могла бы быть реализована?

Для начала попробуем решить эту задачу на уровне языка. Допустим у нас есть объект класса `SomeObject`,
который принадлежит переменной `$obj`, и нам нужно передать объект в другой поток. Это возможно?

```php
$obj = new SomeObject();

$thread = new Thread(function () use ($obj) {
    echo $obj->someMethod();
});

$thread->join();
```

Так как объект `SomeObject` принадлежит только переменной `$obj`,
мы бы могли безопасно перенести его адрес из одного потока в другой. При этом переменная `$obj` в основном потоке
была бы уничтожена:

```php
$obj = new SomeObject();

$thread = new Thread(function () use ($obj) {
    echo $obj->someMethod();
});

// $obj is undefined here

$thread->join();
```

Код выше по сути является 100% аналогом операции перемещения, которая не так давно появилась в `С++`, 
существует в `Rust` и других языках. Такой способ передачи памяти между потоками обладает следующими преимуществами:
1. Безопасность. Только один поток владеет объектом
2. Отсутствие накладных расходов на копирование или сериализацию

Чтобы код имел предсказуемое поведение и правильно считывался статическими анализаторами, следует
добавить специальный синтаксис перемещения, например так:

```php
$obj = new SomeObject();

// consume $obj указывает на перемещение объекта
$thread = new Thread(function () use (consume $obj) {
    echo $obj->someMethod();
});

// $obj is undefined here. Error should be reported here in PHP9.
echo $obj;
```

Выглядит замечательно, не так ли?

Однако у перемещения объектов по `refcount = 1` есть проблемы. 
Рассмотрим дерево категорий:

```php
$electronics = new CategoryNode('Electronics');

$categoriesTree = new Tree();
$categoriesTree->addToPath('/products/electronics', $electronics);
$categoriesTree->addToPath('/popular/electronics', $electronics);  // та же категория!
```

Объект `$electronics` присутствует в дереве дважды (`refcount = 2`).
Но что произойдёт при попытке перемещения `$categoriesTree` в другой поток?

Для безопасного перемещения необходимо гарантировать, что все объекты в графе не имеют внешних ссылок:

```php
$node = new CategoryNode('Electronics');
$categoriesTree = new Tree();
$categoriesTree->addToPath('/products/electronics', $node);

$favourites = [$node];  // внешняя ссылка!

$thread = new Thread(function () use ($categoriesTree) {
    // $categoriesTree перемещён
});

// $favourites[0] теперь указывает на память другого потока
// Dangling pointer!
```

Для гарантированно безопасного перемещения потребовалось бы:

1. **Полный обход графа** — проверка всех вложенных объектов
2. **Проверка refcount** — для каждого объекта в графе
3. **Сохранение идентичности** — дубликаты внутри графа должны остаться дубликатами

Здесь можно придумать несколько вариантов алгоритма, который можно назвать `deep copy`.
Вот так могла бы выглядеть простая реализация:

```php
// Псевдокод deep copy
// Исходный граф в потоке A
$node = new Node('A');        // addr: 0x1000
$tree->left = $node;          // addr: 0x1000
$tree->right = $node;         // addr: 0x1000 (та же ссылка)

// Deep copy в поток B (псевдокод с MM)
$copied_map = [];  // hash table: addr_source -> addr_target

function deepCopyToThread(object $obj, Thread $target_thread_mm) 
{
    $source_addr = get_object_address($obj);

    if (isset($copied_map[$source_addr])) {
        return $copied_map[$source_addr];  // уже скопирован!
    }

    // Аллоцируем память в MM другого потока
    $new_addr = $target_thread_mm->allocate(sizeof($obj));
    $copied_map[$source_addr] = $new_addr;

    // Копируем данные объекта
    memcpy($new_addr, $source_addr, sizeof($obj));

    // Рекурсивно обходим свойства
    foreach ($obj->properties as $prop) {
        if (is_object($prop)) {
            $new_prop_addr = deepCopyToThread($prop, $target_thread_mm);
            // Обновляем указатель в новом объекте
            update_property($new_addr, $prop, $new_prop_addr);
        }
    }

    return $new_addr;
}

// Результат в потоке B:
// $newTree->left (addr: 0x2500) === $newTree->right (addr: 0x2500)
// Идентичность сохранена!
```

**Сложность deep copy**: `O(N + E)`, где `N` — количество объектов, `E` — количество ссылок.
**Пространственная сложность**: `O(N)` — хеш-таблица + новые объекты + стек рекурсии.

По сравнению с сериализацией это может быть более быстрая версия копирования, так как она не требует
преобразования данных в транспортный формат и обратно, но выигрыш зависит от характера данных и размера графа.

Есть возможность создать гибридный алгоритм. 
Он будет перемещать данные с `refcount` = 1, 
и запускать `deep copy` для других типов объектов.

Получаем результат:
1. Программисту `PHP` не нужно задумываться о том, как объекты будут переданы в другой поток
2. В лучшем случае память будет перемещена (`refcount = 1`)
3. В худшем случае память будет скопирована алгоритмом `deep copy` с сохранением идентичности структуры (`refcount > 1`)

Выглядит хорошо: 
* синтаксис `PHP` требует минимальные изменения
* изменения могут быть постепенными
* многопоточность становится доступной 

Однако на уровне ядра языка не всё так замечательно. Чтобы перемещение объекта стало реальностью, 
`PHP` нужен какой-то механизм управления памятью в разных потоках. На текущий момент это невозможно.

## Многопоточная версия PHP Memory Manager

Менеджер памяти `PHP` во многом похож на современные аллокаторы, такие, как `jemalloc` или `tcmalloc`.
Отличие лишь в том, что в нём нет алгоритма корректного освобождения памяти из другого потока.

Рассмотрим ситуацию подробнее:
* Объект создан в потоке `A`
* Объект передан в поток `B` с помощью перемещения (то есть как есть)
* В потоке `B` объект больше не нужен и должен быть освобождён с помощью `free`

В каждом потоке `PHP` есть свой собственный `Memory Manager (MM)`.
Когда поток `B` пытается освободить память, выделенную в потоке `A`, возникает проблема.
Менеджер памяти потока `B` не знает ничего о памяти потока `A`, и попытка освободить её приводит 
к ошибке. Прямой доступ к структурам менеджера памяти потока `A` из потока `B` плохая идея, 
так как требует синхронизации. Современные многопоточные высокопроизводительные менеджеры памяти
решают эту проблему с помощью отложенного освобождения (`deferred free`). 

Общая идея алгоритма `deferred free` в следующем:
1. Менеджер памяти потока `B` видит, что адрес объекта ему неизвестен. 
2. Он находит, какому менеджеру памяти принадлежит указатель, и посылает сообщение в очередь о том, что указатель может быть освобождён
3. Менеджер памяти потока `A` обрабатывает очередь сообщений и освобождает указанные указатели в своём контексте.

![Cross-thread deallocation](diagrams/cross-thread-free.svg)

Такой алгоритм, построенный на современных `lock-free` структурах данных, обладает высокой пропускной способностью, 
позволяет разным потокам параллельно освобождать память и почти не требует блокировок.

Многопоточная версия менеджера памяти `PHP` открывает двери для других изменений, которые раньше
были невозможны.

## Shared objects

Иметь возможность передавать память из одного потока в другой поток с минимумом операций, хорошая вещь, 
но что, если бы мы могли иметь объекты, которые изначально были бы созданы для совместного использования
между потоками?

Многие сервисы могут быть построены как имутабельные объекты, а значит должны иметь возможность честно 
разделяться между разными процессами, что позволит ещё лучше экономить память и быстрее инициализировать воркеры PHP.

Но, к сожалению, для реализации таких объектов мешает `refcount`, так как он по сути 
делает все объекты `PHP` мутабельными! Можно ли это как-то обойти? 

### Proxy objects

Первый подход заключается в создании прокси-объектов, которые будут ссылаться на реальные объекты,
хранящиеся в общем пуле памяти, доступном для всех потоков. Прокси-объекты будут содержать только идентификатор
или указатель на реальный объект, а также методы для доступа к его свойствам и методам. К сожалению, этот способ 
имеет свои недостатки: 
* он увеличивает время обращения к данным и свойствам
* может повысить сложность при работе с `Reflection API`, а также в коде вычисления типа.

С другой стороны, `PHP` уже имеет развитый механизм для создания прокси-объектов. 
В некоторых случаях Proxy-shared объекты, без сомнения, отличный вариант реализации, например для таблицы счётчиков
или таблицы данных наподобие Swoole/Table.

### Shared objects с флагом GC_SHARE

В `PHP` существует встроенный механизм для работы с **immutable** элементами через флаг `GC_IMMUTABLE`.
Этот механизм активно используется для:

- **Интернированные строки** (`IS_STR_INTERNED`) — строковые константы, которые живут всё время работы PHP
- **Immutable массивы** (`IS_ARRAY_IMMUTABLE`) — например, `zend_empty_array`
- **Константы в opcache** — скомпилированный код с константными данными

Флаг `GC_IMMUTABLE` позволяет движку PHP **пропускать** операции изменения `refcount` для таких структур:

```c
// Zend/zend_types.h
// Код функции, которая увеличивает refcount для zend_refcounted_h "типажа"
static zend_always_inline void zend_gc_try_addref(zend_refcounted_h *p) {
    if (!(p->u.type_info & GC_IMMUTABLE)) {
        ZEND_RC_MOD_CHECK(p);
        ++p->refcount;
    }
}
```

Похожий механизм можно использовать, чтобы корректно работать с `SharedObjects`. Например, определить флаг
`GC_SHARE`.

Анализ производительности показывает, что проверка флага `GC_SHARE` 
добавляет **+34% overhead** к изолированной операции `refcount++` (микробенчмарк).
В реальных приложениях, где операция с `refcount` составляет малую долю от общей работы, 
влияние должно быть практически незаметно:

- **Реалистичные операции** (работа с массивами/объектами): +3-9%
- **Реальные приложения**: +0.05-0.5%

Такой подход решает половину проблемы, вторая половина состоит в разработке механизма сборки мусора для такого объекта. 
Использовать `atomic refcount` не самая лучшая идея из-за возможного снижения производительности
при активном доступе разных потоков к одному объекту. Вероятнее всего тут подойдёт алгоритм `deferred free`.

### Region-based memory

Сейчас `region-based memory` является популярным подходом для управления памятью 
в языках программирования, ориентированных на web.

Идея заключается в том, чтобы выделять память для определённых задач или потоков в отдельных регионах,
которые могут быть освобождены целиком (или почти целиком), когда они больше не нужны.
Это позволяет избежать сложностей с управлением памятью на уровне отдельных объектов
и упрощает работу GC.

Так, например, `PHP MM` может гарантировать создание объектов в определённом регионе памяти,
который будет связан с конкретным PHP-объектом.
Время жизни региона равно времени жизни объекта.

Когда объект уничтожается, весь регион памяти может быть освобождён целиком,
без обхода дочерних элементов. А если такой объект нужно "переместить" из потока в поток,
можно избежать операции `deep copy`.

PHP VM имеет проблемы с реализацией `region-based memory`, 
например глобальный список объектов, кеширование в опкодах. Но шансы на эффективную реализацию 
не равны нулю и требуют дальнейших исследований.

Работающий алгоритм `region-based memory` открывает возможности 
к имплементации акторов, специальных объектов,
с изолированной памятью.

Акторы являются самым удобным, мощным и безопасным инструментом для многопоточного программирования.

## Взаимодействие корутин и Threads

С точки зрения корутины `Thread` — это `Awaitable`-объект. Значит 
корутина может ожидать результат выполнения `Thread`, не блокируя другие корутины. То есть в одном
потоке может существовать множество корутин, ожидающих выполнения тяжёлых задач. 
При этом поток, обслуживающий корутины, будет сохранять способность быстро реагировать на новые запросы, 
ведь ожидание `Thread` не блокирует `Event Loop`.

```php
use Async\await;
use Async\Thread;

$thread = new Thread(function() {
    // hardware-bound task here
    return 42;
});

$result = await($thread); // Корутина останавливается здесь, до завершения Thread
```

С помощью подобного подхода можно реализовать сценарий работы чата, 
в котором есть `CPU-интенсивные` задачи и простая бизнес-логика.

![Thread + Coroutine architecture](diagrams/chat-sequence.svg)

На диаграмме вы можете увидеть пример архитектуры.
Приложение состоит из двух пулов потоков: потоки обработки запросов с конкурентной многозадачностью, 
и потоки worker для `CPU-интенсивных` задач. Корутина обрабатывает один запрос, может полностью остановиться, ожидая, 
когда поток worker выполнит тяжёлую задачу, и затем продолжить обработку запроса.

```php
use Async\await;
use Async\ThreadPool;

final readonly class ImageDto
{
    public function __construct(
    public int $width,
    public int $height,
    public string $text,
) {}
}

$pool = new ThreadPool(2);
$dto = new ImageDto(
    width: 200,
    height: 200,
    text: 'Hello TrueAsync!'
);

$image = $pool->enqueue(function (ImageDto $dto) {
    $img = imagecreatetruecolor($dto->width, $dto->height);

    $white = imagecolorallocate($img, 255, 255, 255);
    $black = imagecolorallocate($img, 0, 0, 0);

    imagefill($img, 0, 0, $white);
    imagestring($img, 5, 20, 90, $dto->text, $black);

    ob_start();
    imagepng($img);
    imagedestroy($img);
    return ob_get_clean();
}, $dto);

$response->setHeader('Content-Type', 'image/png');
$response->write($image);
$response->end();
```

Код корутины выглядит последовательно и воспринимается так же, как если бы это был обычный код, 
где `ThreadPool::enqueue` вызывал бы callback в том же потоке.
Объект `DTO` переходит от одного потока в другой, а результирующая строка не копируется в памяти дважды.

## Garbage Collector и stateful режим

Модернизация менеджера памяти PHP не единственное изменение, которое необходимо, чтобы улучшить 
работу языка для многопоточной среды. Без эффективного сборщика мусора многопоточный PHP
будет страдать от проблем с производительностью и утечками памяти из-за циклов сборки мусора.

Garbage Collector `PHP` использует комбинацию двух алгоритмов: **reference counting** (подсчёт ссылок)
как основной механизм управления памятью и **Concurrent Cycle Collection** (алгоритм Bacon-Rajan, 2001)
для обнаружения циклических ссылок. Reference counting инкрементирует и декрементирует счётчик при каждом
присваивании переменной, что делает невозможным его безопасное использование в многопоточной среде без
синхронизации. Атомарные операции для каждого присваивания создали бы огромный overhead,
а отсутствие синхронизации привело бы к `race conditions` и утечкам памяти. `Cycle collector`, хотя и
называется "concurrent", работает только в контексте одного потока и использует цветовую маркировку
(**PURPLE** → **GREY** → **WHITE/BLACK**) для обнаружения циклов, которая также не является `thread-safe`.

Позитивный момент состоит в том, что текущая реализация Garbage Collector `PHP` 
будет работать в многопоточной среде, так как она отделена от менеджера памяти и не зависит 
от того, где на самом деле память была выделена. 

Но если `PHP` хочет войти в многопоточную эру stateful приложений,
сборщик мусора должен быть адаптирован так, чтобы решить следующие задачи:
1. Уметь работать **параллельно** в отдельном потоке, не влияя на работу бизнес-кода
2. Эффективно освобождать ресурсы так быстро, как это возможно
3. Предоставлять дополнительные инструменты для обнаружения, логирования утечек памяти, телеметрии (особенно актуально для длительно работающих приложений!)

Алгоритм `Cycle Collection` может быть изменён для работы в многопоточной среде, 
обрабатывая ссылки в отдельном потоке, что повысит общую отзывчивость `PHP` приложения. 
И для начала этого может быть достаточно!

## Акторы

Конечно, `ThreadPool` и возможность передавать объекты между потоками полезно,
но требует от программиста внимания, квалификации и усилий. Существует
лучшая абстракция для многопоточного программирования, которая скрывает
сложности работы с потоками и памятью и идеально подходит для бизнес-логики. 
Называется она — **Акторы**.

Акторы — это модель конкурентного параллельного программирования, 
в которой базовой единицей вычислений является **актор**.

Каждый актор:
- Имеет собственное изолированное состояние
- Обрабатывает сообщения последовательно
- Взаимодействует с другими акторами только через сообщения
- Может выполняться в отдельном потоке

Об акторе можно думать так же, как и об объекте, что делает возможным 
использование привычных для PHP парадигм ООП в многопоточном программировании.

Представьте чат-сервер с множеством комнат. Каждая комната — отдельный объект.

```php
use Async\Actor;

class ChatRoom extends Actor
{
    private array $messages = [];
    private string $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function postMessage(string $user, string $text): void
    {
        $this->messages[] = [
            'user' => $user,
            'text' => $text,
            'time' => time()
        ];
    }

    public function getMessages(): array
    {
        return $this->messages;
    }
}

spawn(function() {
   $room = new ChatRoom('general');
   $room->postMessage('Alice', 'Hello!');  // Выполняется в другом потоке, блокирует корутину!
   $messages = $room->getMessages();       // Выполняется в другом потоке, блокирует корутину!
   echo json_encode($messages);
});
```

Объекты класса `ChatRoom` являются особенными. Их данные, состояние PHP VM 
локализированы так, чтобы легко перемещаться между потоками. Каждый метод 
класса `ChatRoom` выполняется отдельно в своём потоке, но таким образом, 
что в один момент времени только один поток может выполнять методы одного актора.

С точки зрения семантики языка, базовый класс `Actor` определяет 
работу `PHP VM` и менеджера памяти так, чтобы объекты класса `ChatRoom`
могли безопасно выполняться в отдельных потоках. То есть тип класса "хранит" не только
информацию о методах и свойствах, но и о том, как должен работать менеджер памяти
и сборщик мусора для таких объектов. Похожий подход можно увидеть в
других языках программирования: `Rust`, `C++`. Плюс данного подхода в том, что 
он не требует изменений в синтаксисе языка и органично вписывается в существующую философию ООП.

Пример напоминает обычный последовательный код, который выполняется внутри корутины. 
Но так как методы `postMessage` и `getMessages` выполняются в другом потоке, на самом деле 
не происходит их прямого выполнения. Корутина посылает **сообщение** в очередь актора, 
переходит в состояние ожидания, и возобновляется только тогда, 
когда актор выполнит метод в другом потоке и вернёт результат.

Ничего из этого не противоречит привычной модели `ООП` в PHP, так как в классе `Actor` 
переопределён магический метод `__call`:

```php
class Actor 
{
    private $threadPool;

    public function __call(string $name, array $arguments): mixed
    {
        if(current_thread_id() === $this->threadPool->getThreadIdForActor($this)) {
            // Выполняем метод напрямую, если мы в том же потоке
            return $this->$name(...$arguments);
        }
    
        // Иначе ставим вызов в очередь актора
        return $this->threadPool->enqueueActorMethod($this, $name, $arguments);
    }
}
```

Метод `enqueueActorMethod` добавляет в очередь актора вызов `postMessage`,
подписывается на событие результата, и вызывает функцию `Async\suspend()` для остановки корутины. 

Код актора выполняется последовательно, что решает проблемы гонки данных 
и делает многопоточную разработку прозрачной для программиста.

Распараллеливание достигается за счёт того, что каждый актор `ChatRoom`
получает шанс выполняться в отдельном потоке:

```php
spawn(function() {
   $room = new ChatRoom('room1');
   $room->postMessage('Alice', 'Hello!');
   $messages = $room->getMessages();
   echo json_encode($messages);
});

spawn(function() {
   $room = new ChatRoom('room2');
   $room->postMessage('Bob', 'Hi there!');
   $messages = $room->getMessages();
   echo json_encode($messages);
});
```

Код разных объектов `ChatRoom` может выполняться параллельно в разных потоках,
ведь каждый актор имеет свой собственный поток выполнения, уникальное состояние PHP VM и память.

Создадим **100 чат-комнат**:

```php
use Async\Actor;

$rooms = [
    'general' => new ChatRoom('general'),
    'random'  => new ChatRoom('random'),
    'tech'    => new ChatRoom('tech'),
    // ... ещё 97 комнат
];

// Корутина для обработки запросов
HttpServer::onRequest(function(Request $request, Response $response) use ($rooms) {
   // Обработка HTTP запроса
   $roomName = $request->getQueryParam('room');
   $room = $rooms[$roomName] ?? null;
   
   if (!$room) {
      $response->setStatus(404);
      $response->write('Room not found');
      $response->end();
      return;
   }
   
   // Вызовы выглядят синхронно, но выполняются в другом потоке!
   $room->postMessage($request->getQueryParam('user'), $request->getQueryParam('text'));
   $messages = $room->getMessages();
   
   $response->setHeader('Content-Type',  'application/json');  
   $response->write(json_encode($messages));
   $response->end();
});
```

Каждая чат-комната будет обрабатывать сообщения последовательно и при этом параллельно
относительно других чат-комнат. 

Акторы не требуют мьютексов, блокировок, сложной синхронизации или ручного взаимодействия с пулом потоков.
Они предоставляют готовое высокоуровневое решение для распараллеливания задач.

Если одной чат-комнате требуется послать сообщение в другую чат-комнату, это
возможно, ведь акторы являются `SharedObject`, могут взаимодействовать в разных потоках:

```php
class Rooms extends Actor
{
    private array $rooms = [];
    
    public function __construct(string ...$roomNames)
    {
       foreach ($roomNames as $name) {
           $this->rooms[$name] = new ChatRoom($name);
       }
    }
    
    public function broadcastMessage(string $fromRoom, string $user, string $text): void
    {
        foreach ($this->rooms as $name => $room) {
            if ($name !== $fromRoom) {
                // Неблокирующий вызов
                $room->postMessageAsync($user, $text);
            }
        }
    }
}

spawn(function() {
   $rooms = new Rooms('general', 'room1', 'room2', 'room3');
   $rooms->broadcastMessage('general', 'Alice', 'Hello!');
});

```        
    
### Внутренняя архитектура акторов

PHP VM гарантирует, что все объекты внутри актора:
* либо принадлежат только этому актору и выделены в его уникальном region
* либо принадлежат и были перемещены из других регионов или потоков
* либо являются другим SharedObject или другим актором

Актор либо владеет своим region, либо работает только с явно разделяемыми immutable объектами — иначе остаются гонки.

Менеджер памяти обеспечивает и гарантирует, что все операции с памятью внутри методов Актора
автоматически связаны с ним через регион памяти, прямо ассоциированный с актором.

Для выполнения методов используется `MPMC` очередь сообщений, 
которую обслуживает `Scheduler`. Именно `Scheduler` распределяет время процессора 
между акторами, обеспечивая конкурентное и параллельное выполнение.

![Actor model architecture](diagrams/actor-message-flow.svg)

## Заключение

Всё это, конечно, хорошо, но когда же мы сможем это увидеть в реальности? Спросите вы.

Модель `Single-threaded + offload` может появиться в ближайшее время, так как множество 
компонентов уже готовы. `TrueAsync`: однопоточные корутины добрались до состояния беты. Реализована 
экспериментальная версия многопоточного менеджера памяти и `API` для создания потоков. 

Акторы требуют больше времени на разработку, так как затрагивают множество частей ядра `PHP`,
и остаются реалистичной целью для `PHP 9`, предлагая рынку безопасный многопоточный язык программирования.
